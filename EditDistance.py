# Вычислите расстояние редактирования двух данных
# непустых строк длины не более 10^2,
# содержащих строчные буквы латинского алфавита.

# импортируем библиотеку random
import random
# модуль sys для работы с ограничением глубины рекурсии
# import sys
# импорт декоратора lru_cache
from functools import lru_cache

# рекурсивная реализация
def edit_distance1(s1, s2):
    # мемонизируем выполнение функции с помощью
    # декоратора lru_cache неограниченного размера
    @lru_cache(maxsize=None)
    # локальная функция от i и j,
    # которые содержат длины двух строк,
    # для которых считаем редакционное расстояние d
    def d(i, j):
        # разберем случай пустых строк
        if i == 0 or j == 0:
            # выражаем длину максимальной строки
            # (или 0, если обе строки пустые)
            return max(i, j)
        else:
            return min(d(i, j - 1) + 1, # вставка
                       d(i - 1, j) + 1, # удаление
                       # добавляем еденицу, если соответствующие символы не равны
                       d(i - 1, j - 1) + (s1[i - 1] != s2[j - 1])) # (не) соответствие
    return d(len(s1), len(s2))

# реализация циклом с экономией памяти
def edit_distance2(s1, s2):
    m, n = len(s1), len(s2)

    # матрица D, проинициализированная нулями

    d = [[0] * (n + 1) for _ in range(m + 1)]

    # случай пустых строк
    # (заполняем нулевые строку и столбец)

    for i in range(m + 1):
        d[i][0] = i
    for j in range(n + 1):
        d[0][j] = j

    # заполнение оставшейся части таблицы !построчно!
    for i in range(1, m + 1):
        for j in range(1, n +1):
            d[i][j] = min(d[i][j - 1] + 1, # вставка
                       d[i - 1][j] + 1, # удаление
                       # добавляем еденицу, если соответствующие символы не равны
                       d[i - 1][j - 1] + (s1[i - 1] != s2[j - 1])) # (не) соответствие

    return d[m][n]

# реализация циклом с экономией памяти
def edit_distance3(s1, s2):
    m, n = len(s1), len(s2)

    # помним предыдущую строчку,
    # изначально проинициализированную элементами от 1 до n+1
    prev = list(range(n + 1))
    # Функция enumerate принимает что-то по чему
    # можно итерироваться и опциональный индекс первого элемента
    # Возвращает последовательность пар,
    # где i это это индекс, сh1 - (i-1) строки s1
    for i, ch1 in enumerate(s1,1):
        # помним текущую строчку длины n + 1,
        # где в первом элементе лежит ее индекс
        curr = [0] * (n + 1)
        curr[0] = i
        for j, ch2 in enumerate(s2, 1):
            curr[j] = min(curr[j - 1] + 1, # вставка
                       prev[j] + 1, # удаление
                       # добавляем еденицу, если соответствующие символы не равны
                       prev[j - 1] + (ch1 != ch2)) # (не) соответствие
        prev = curr # после завершения итерации j нужно обновить предыдущую строку
    return prev[n]

# максимально эффективная реализация
def edit_distance4(s1, s2):
    m, n = len(s1), len(s2)

    # O(min(m, n)) - memory
    # Для гарантии этого по памяти условия необходимо заполнять матрицу
    # по более короткому элементу: столбцам (m - min) или строкам (n - min)

    # делаем заполнение по столбцам при выполнении условия m < n
    if m < n:
        return edit_distance4(s2, s1)

    prev = list(range(n + 1))
    # заполнение оставшейся части таблицы !построчно!
    for i, ch1 in enumerate(s1,1):
        # инициализируем текущую номером строки
        curr = [i] # O(n) - memory
        for j, ch2 in enumerate(s2, 1):
            # в цикле добавляем конец элемента
            curr.append(min(curr[-1] + 1, # вставка(интересует последний элемент curr)
                       prev[j] + 1, # удаление
                       # (не) соответствие
                       prev[j - 1] + (ch1 != ch2)))
        prev = curr
    return prev[n]

def main():
    # считываем из стандартного входа две строки
    s1 = input()
    s2 = input()
    # распечатывем дистанцию между строками
    print(edit_distance4(s1, s2))

# функция теста принимает один аргумент - количество случайных проверок

def test(n_iter=100):
    # range(start, stop, step) - в цикле задается параметр,
    # его стартовое и конечное значение, а так же шаг цикла
    for i in range(n_iter): # используем только конечный параметр stop
        # на каждом шаге выбираем случайную длину от 0 до 64
        length = random.randint(0, 64) # при большой длине строки получаем ошибку: превышен лимит глубины рекурсии
        # сгенерируем строку в формате 01
        s = "".join(random.choice("01") for _ in range(length))
        # коррекционное расстояние между строкой и пустой строкой равно длине строки
        # а так же симметрично
        assert edit_distance4(s, "") == edit_distance2("", s) == len(s)
        assert edit_distance4(s, s) == 0

        assert edit_distance4("ab", "ab") == 0
        # short-
        # p-orts
        assert edit_distance4("short", "ports") == 3


# name хранит название модуля, который нужно запустить
if __name__ == "__main__":
    # установка лимита на глубину рекурсии в 10000
    # sys.setrecursionlimit(10000)
    test()